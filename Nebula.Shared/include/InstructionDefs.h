#pragma once

#ifndef _NEBULA_INST_NAMES_H_
#define _NEBULA_INST_NAMES_H_

#include <map>
#include <string>

#include "Utility.h"

namespace nebula {

	/// <summary> Despite the names in this enum all instructions will be emitted/read as lower case identifiers </summary>
	enum class VMInstruction {
		Nop,

		Pop,
		Dup,

		Call,
		CallVirt,

		// Conversion
		ConvType,

		// Control flow 
		Ret,
		Br,
		BrTrue,
		BrFalse,
		Ceq,
		Neg,
		Not,
		And,
		Or,
		Xor,
		Clt,
		Cgt,

		// Threads
		Call_t,
		Wait,
		Wait_n,
		Notify,

		// Math
		Add,
		Sub,
		Mul,
		Div,
		Rem,

		// String
		AddStr,

		// Load
		Ldc_i4_0,
		Ldc_i4_1,
		Ldc_i4,
		Ldc_r4,
		Ldc_s,
		Newobj,
		NewArr,

		// Load variables
		Ldarg,
		Ldloc,
		LdElem,
		LdFld,

		// Store
		Stloc,
		StArg,
		StElem,
		StFld,

		LastInstruction
	};

	enum class VMAttribute
	{
		Unknown,
		// Automatically generates a routine as soon as the VM is started or the script is loaded
		AutoExec,
		// Always paired with autoexec, on VM start autoexec functions are ordered by this attribute
		// If a deadlock is detected execution is aborted
		ExecAfter,

		// Internal use only, marks a function as auto generated by the compiler
		Autogenerated,

		LastAttribute,
	};

	// All the secions that can be found in a script
	enum class ScriptSection
		: uint8_t
	{
		Namespace,	// Namespace of script
		Function,	// Function data
		Bundle,		// Bundle definition
		Locals,		// Variables defined in scope
	};

	static inline constexpr const char* ReadableScriptSection(ScriptSection s)
	{
		switch (s)
		{
		case ScriptSection::Namespace:
			return "namespace";
		case ScriptSection::Function:
			return "func";
		case ScriptSection::Bundle:
			return "bundle";
		case ScriptSection::Locals:
			return "locals";
		}
		return nullptr;
	}

	/// <summary>
	/// Converts an instruction to string
	/// </summary>
	static inline constexpr const char* itos(const VMInstruction inst)
	{
		switch (inst)
		{
		case VMInstruction::Nop:
			return "nop";
		case VMInstruction::Pop:
			return "pop";
		case VMInstruction::Dup:
			return "dup";
		case VMInstruction::Call:
			return "call";
		case VMInstruction::CallVirt:
			return "callvirt";
		case VMInstruction::ConvType:
			return "convtype";
		case VMInstruction::Ret:
			return "ret";
		case VMInstruction::Br:
			return "br";
		case VMInstruction::BrTrue:
			return "brtrue";
		case VMInstruction::BrFalse:
			return "brfalse";
		case VMInstruction::Ceq:
			return "ceq";
		case VMInstruction::Neg:
			return "neg";
		case VMInstruction::Not:
			return "not";
		case VMInstruction::And:
			return "and";
		case VMInstruction::Or:
			return "or";
		case VMInstruction::Xor:
			return "xor";
		case VMInstruction::Clt:
			return "clt";
		case VMInstruction::Cgt:
			return "cgt";
		case VMInstruction::Call_t:
			return "call_t";
		case VMInstruction::Wait:
			return "wait";
		case VMInstruction::Wait_n:
			return "wait_n";
		case VMInstruction::Notify:
			return "notify";
		case VMInstruction::Add:
			return "add";
		case VMInstruction::Sub:
			return "sub";
		case VMInstruction::Mul:
			return "mul";
		case VMInstruction::Div:
			return "div";
		case VMInstruction::AddStr:
			return "addstr";
		case VMInstruction::Ldc_i4_0:
			return "ldc_i4_0";
		case VMInstruction::Ldc_i4_1:
			return "ldc_i4_1";
		case VMInstruction::Ldc_i4:
			return "ldc_i4";
		case VMInstruction::Ldc_s:
			return "ldc_s";
		case VMInstruction::Ldarg:
			return "ldarg";
		case VMInstruction::Ldloc:
			return "ldloc";
		case VMInstruction::Stloc:
			return "stloc";
		case VMInstruction::NewArr:
			return "newarr";
		case VMInstruction::LdElem:
			return "ldelem";
		}

		return nullptr;
	}
	static inline bool stoi(const char* s, VMInstruction& val) {
		static std::map<std::string, VMInstruction> instructionMap = {
			{"nop",			VMInstruction::Nop			},
			{"pop",			VMInstruction::Pop			},
			{"dup",			VMInstruction::Dup			},
			{"callvirt",	VMInstruction::CallVirt 	},
			{"call",		VMInstruction::Call			},
			{"convtype",	VMInstruction::ConvType		},
			{"ret",			VMInstruction::Ret			},
			{"br",			VMInstruction::Br			},
			{"brtrue",		VMInstruction::BrTrue		},
			{"brfalse",		VMInstruction::BrFalse		},
			{"ceq",			VMInstruction::Ceq			},
			{"neg",			VMInstruction::Neg			},
			{"not",			VMInstruction::Not			},
			{"and",			VMInstruction::And			},
			{"or",			VMInstruction::Or			},
			{"xor",			VMInstruction::Xor			},
			{"clt",			VMInstruction::Clt			},
			{"cgt",			VMInstruction::Cgt			},
			{"call_t",		VMInstruction::Call_t		},
			{"wait",		VMInstruction::Wait			},
			{"wait_n",		VMInstruction::Wait_n		},
			{"notify",		VMInstruction::Notify		},
			{"add",			VMInstruction::Add			},
			{"sub",			VMInstruction::Sub			},
			{"mul",			VMInstruction::Mul			},
			{"div",			VMInstruction::Div			},
			{"rem",			VMInstruction::Rem			},
			{"addstr",		VMInstruction::AddStr		},
			{"ldc_i4_0",	VMInstruction::Ldc_i4_0		},
			{"ldc_i4_1",	VMInstruction::Ldc_i4_1		},
			{"ldc_i4",		VMInstruction::Ldc_i4		},
			{"ldc_r4",		VMInstruction::Ldc_r4		},
			{"ldc_s",		VMInstruction::Ldc_s		},
			{"ldarg",		VMInstruction::Ldarg		},
			{"ldloc",		VMInstruction::Ldloc		},
			{"ldfld",		VMInstruction::LdFld		},
			{"ldelem",		VMInstruction::LdElem		},
			{"starg",		VMInstruction::StArg		},
			{"stloc",		VMInstruction::Stloc		},
			{"stfld",		VMInstruction::StFld		},
			{"stelem",		VMInstruction::StElem		},
			{"newobj",		VMInstruction::Newobj		},
			{"newarr",		VMInstruction::NewArr		},
		};

		auto instPair = instructionMap.find(s);
		if (instPair == instructionMap.end())
		{
#if _DEBUG
			__debugbreak();
#endif
			val = VMInstruction::LastInstruction;
			return false;
		}

		val = instPair->second;
		return true;
	}
	static inline bool stoi(const std::string& s, VMInstruction& val) { return stoi((const char*)s.data(), val); }
	static inline constexpr const char* atos(const VMAttribute attr) {
		switch (attr)
		{
		case VMAttribute::AutoExec:
			return "autoexec";
		case VMAttribute::ExecAfter:
			return "execafter";
		case VMAttribute::Autogenerated:
			return "autogenerated";
		}

		return nullptr;
	}
	static inline bool stoattr(const char* s, VMAttribute& val) {
		if (strncmp("autoexec", s, cstrlen("autoexec")) == 0)
		{
			val = VMAttribute::AutoExec;
			return true;
		}

		if (strncmp("execafter", s, cstrlen("execafter")) == 0)
		{
			val = VMAttribute::ExecAfter;
			return true;
		}

		if (strncmp("autogenerated", s, cstrlen("autogenerated")) == 0)
		{
			val = VMAttribute::Autogenerated;
			return true;
		}

		val = VMAttribute::Unknown;
		return false;
	}

	enum class SpecialDataType
	{
		Unknown,
		Locals,
	};

	inline SpecialDataType StringToSpecialDataType(const std::string& str)
	{
		static std::map<std::string, SpecialDataType> valMap = {
			{ "unknown",	SpecialDataType::Unknown },
			{ "locals",	    SpecialDataType::Locals },
		};

		auto it = valMap.find(str);
		if (it == valMap.end())
		{
			return SpecialDataType::Unknown;
		}

		return it->second;
	}
}

#endif // !_NEBULA_INST_NAMES_H_
