#pragma once

#ifndef _NEBULA_INST_NAMES_H_
#define _NEBULA_INST_NAMES_H_

#include "Utility.h"
#include <map>

namespace nebula {
    /// <summary>
    /// Despite the names in this enum all instructions will be emitted/read as lower case identifiers
    /// </summary>
    enum class VMInstruction {
        Nop,		// Empty operation

        Pop,		// Pop the value on top of the stack
        Dup,		// Duplicates value on top of stack

        Call,		// Invoke function

        // Conversion
        ConvType,	// Convert the top of the stack value from to [type]

        // Control flow 
        Ret,		// Return control flow
        Br,			// Jump always
        BrTrue,		// Jump if true
        BrFalse,	// Jump if false
        Ceq,		// Compares two values on the stack and pushes 1 if they're equal otherwise 0
        Neg,		// Negates the value on top of the stack
        Not,		// 
        And,
        Or,
        Xor,
        Clt,
        Cgt,

        // Threads
        Call_t,
        Wait,
        Wait_n,
        Notify,

        // Math
        Add,
        Sub,
        Mul,
        Div,
        Rem,		// Pushes the remainer of a division onto the stack

        // String
        AddStr,

        // Load
        Ldc_i4_0,	// Load constant i32 0
        Ldc_i4_1,	// Load constant i32 1
        Ldc_i4,		// Load constant i32
        Ldc_r4,		// Load constant f32
        Ldc_s,		// Load string constant
        Ld_b,       // Load bundle [optional arg 'BundleName' ]

        // Load variables
        Ldarg,
        LdBarg,     // Read data in parameter bundle and put it on top of stack
        Ldloc,
        LdBloc,     // Read data in local bundle and put it on top of stack

        // Store
        Stloc,		// Store local variable
        StBloc,     // Store data in local bundle
        StArg,
        StBArg,

        LastInstruction
    };

    enum class VMAttribute
    {
        uknown,
        // Automatically generates a routine as soon as the VM is started or the script is loaded
        autoexec,
        // Always paired with autoexec, on VM start autoexec functions are ordered by this attribute
        // If a deadlock is detected execution is aborted
        execAfter,

        // Internal use only, marks a function as auto generated by the compiler
        autogenerated,

        LastAttribute,
    };

    // All the secions that can be found in a script
    enum class ScriptSection
        : uint8_t
    {
        Namespace,	// Namespace of script
        Function,	// Function data
        Bundle,		// Bundle definition
        Locals,		// Variables defined in scope
    };

    static inline constexpr const char* ReadableScriptSection(ScriptSection s)
    {
        switch (s)
        {
        case ScriptSection::Namespace:
            return "namespace";
        case ScriptSection::Function:
            return "func";
        case ScriptSection::Bundle:
            return "bundle";
        case ScriptSection::Locals:
            return "locals";
        }
        return nullptr;
    }

    /// <summary>
    /// Converts an instruction to string
    /// </summary>
    static inline constexpr const char* itos(const VMInstruction inst)
    {
        switch (inst)
        {
        case VMInstruction::Nop:
            return "nop";
        case VMInstruction::Pop:
            return "pop";
        case VMInstruction::Dup:
            return "dup";
        case VMInstruction::Call:
            return "call";
        case VMInstruction::ConvType:
            return "convtype";
        case VMInstruction::Ret:
            return "ret";
        case VMInstruction::Br:
            return "br";
        case VMInstruction::BrTrue:
            return "brtrue";
        case VMInstruction::BrFalse:
            return "brfalse";
        case VMInstruction::Ceq:
            return "ceq";
        case VMInstruction::Neg:
            return "neg";
        case VMInstruction::Not:
            return "not";
        case VMInstruction::And:
            return "and";
        case VMInstruction::Or:
            return "or";
        case VMInstruction::Xor:
            return "xor";
        case VMInstruction::Clt:
            return "clt";
        case VMInstruction::Cgt:
            return "cgt";
        case VMInstruction::Call_t:
            return "call_t";
        case VMInstruction::Wait:
            return "wait";
        case VMInstruction::Wait_n:
            return "wait_n";
        case VMInstruction::Notify:
            return "notify";
        case VMInstruction::Add:
            return "add";
        case VMInstruction::Sub:
            return "sub";
        case VMInstruction::Mul:
            return "mul";
        case VMInstruction::Div:
            return "div";
        case VMInstruction::AddStr:
            return "addstr";
        case VMInstruction::Ldc_i4_0:
            return "ldc_i4_0";
        case VMInstruction::Ldc_i4_1:
            return "ldc_i4_1";
        case VMInstruction::Ldc_i4:
            return "ldc_i4";
        case VMInstruction::Ldc_s:
            return "ldc_s";
        case VMInstruction::Ldarg:
            return "ldarg";
        case VMInstruction::Ldloc:
            return "ldloc";
        case VMInstruction::Stloc:
            return "stloc";
        }

        return nullptr;
    }
    static inline bool stoi(const char* s, VMInstruction& val) {
        static std::map<std::string, VMInstruction> instructionMap = {
            {"nop",			VMInstruction::Nop			},
            {"pop",			VMInstruction::Pop			},
            {"dup",			VMInstruction::Dup			},
            {"call",		VMInstruction::Call			},
            {"convtype",	VMInstruction::ConvType		},
            {"ret",			VMInstruction::Ret			},
            {"br",			VMInstruction::Br			},
            {"brtrue",		VMInstruction::BrTrue		},
            {"brfalse",		VMInstruction::BrFalse		},
            {"ceq",			VMInstruction::Ceq			},
            {"neg",			VMInstruction::Neg			},
            {"not",			VMInstruction::Not			},
            {"and",			VMInstruction::And			},
            {"or",			VMInstruction::Or			},
            {"xor",			VMInstruction::Xor			},
            {"clt",			VMInstruction::Clt			},
            {"cgt",			VMInstruction::Cgt			},
            {"call_t",		VMInstruction::Call_t		},
            {"wait",		VMInstruction::Wait			},
            {"wait_n",		VMInstruction::Wait_n		},
            {"notify",		VMInstruction::Notify		},
            {"add",			VMInstruction::Add			},
            {"sub",			VMInstruction::Sub			},
            {"mul",			VMInstruction::Mul			},
            {"div",			VMInstruction::Div			},
            {"rem",			VMInstruction::Rem			},
            {"addstr",		VMInstruction::AddStr		},
            {"ldc_i4_0",	VMInstruction::Ldc_i4_0		},
            {"ldc_i4_1",	VMInstruction::Ldc_i4_1		},
            {"ldc_i4",		VMInstruction::Ldc_i4		},
            {"ldc_r4",		VMInstruction::Ldc_r4		},
            {"ldc_s",		VMInstruction::Ldc_s		},
            {"ld_b",		VMInstruction::Ld_b		    },
            {"ldarg",		VMInstruction::Ldarg		},
            {"ldloc",		VMInstruction::Ldloc		},
            {"stloc",		VMInstruction::Stloc		},
            {"stbloc",		VMInstruction::StBloc		},
            {"starg",		VMInstruction::StArg		},
            {"stbarg",		VMInstruction::StBArg		},
            {"ldbloc",		VMInstruction::LdBloc		},
            {"ldbarg",		VMInstruction::LdBarg		},
        };

        auto instPair = instructionMap.find(s);
        if (instPair == instructionMap.end())
        {
#if _DEBUG
            __debugbreak();
#endif
            val = VMInstruction::LastInstruction;
            return false;
        }

        val = instPair->second;
        return true;
    }
    static inline bool stoi(const std::string& s, VMInstruction& val) { return stoi((const char*)s.data(), val); }
    static inline constexpr const char* atos(const VMAttribute attr) {
        switch (attr)
        {
        case VMAttribute::autoexec:
            return "autoexec";
        case VMAttribute::execAfter:
            return "execAfter";
        case VMAttribute::autogenerated:
            return "autogenerated";
        }

        return nullptr;
    }
    static inline bool stoattr(const char* s, VMAttribute& val) {
        if (strncmp("autoexec", s, cstrlen("autoexec")) == 0)
        {
            val = VMAttribute::autoexec;
            return true;
        }

        if (strncmp("execAfter", s, cstrlen("execAfter")) == 0)
        {
            val = VMAttribute::execAfter;
            return true;
        }

        if (strncmp("autogenerated", s, cstrlen("autogenerated")) == 0)
        {
            val = VMAttribute::autogenerated;
            return true;
        }

        val = VMAttribute::uknown;
        return false;
    }

    enum class SpecialDataType
    {
        Unknown,
        Locals,
    };

    inline SpecialDataType StringToSpecialDataType(const std::string& str)
    {
        static std::map<std::string, SpecialDataType> valMap = {
            { "unknown",	SpecialDataType::Unknown },
            { "locals",	    SpecialDataType::Locals },
        };

        auto it = valMap.find(str);
        if (it == valMap.end())
        {
            return SpecialDataType::Unknown;
        }

        return it->second;
    }
}

#endif // !_NEBULA_INST_NAMES_H_
